## 인증과 인가

- 인증이란, 데이터(식별 가능한 정보)로 서비스에 등록된 유저의 신원을 입증하는 과정.
- 인가란, 인증된 사용자에 대한 자원 접근 권한 확인.

인증을 받은 사용자는 인가(권한 허가) 받은 곳만 방문할 수 있다.

웹에서는 로그인/회원가입 과정에 해당한다. 이 과정과 동시에 권한도 획득한다(예를 들어, 글을 쓸 수 있는 권한 등). 즉 이 과정에 인증과 인가가 적용되어 있다.

자원을 적절한/유효한 사용자에게 전달/공개하기 위한 방법이 "인증과 인가"이다.

1. 인증하기 (로그인하기) : Request Header 방식 사용 가능
2. 인증 유지하기 : Browser의 힘을 빌리기
3. 안전하게 인증하기 : Server를 통해서
4. 효율적으로 인증하기 : Token을 사용해서
5. 다른 채널을 통해 인증하기 : OAuth를 사용해서

### 사전지식.

- 클라이언트 서버는 HTTP로 소통(통신)을 한다.
- HTTP의 특징 중 하나는 무상태성(stateless)이다.

서버는 클라이언트가 보낸 요청과 그 다음 요청에 대한 연관 관계가 없다고 생각하고 요청을 받고 처리를 한다.

## Request Header

### 1. Request Header 활용하기

사용자가 특정 웹사이트로 접근을 해서 로그인 요청을 보낸다. api가 구축되어 있는 상황이라면, id와 pw를 웹사이트 앞에 달아주기만 해도 로그인 요청이 간다. (`http://user:1q2w3e!www.dasdas.com/login`)

이걸 브라우저가 처리해주는데,<br>
url을 base64라는 인코더를 사용해서 인코딩을 한 후에 전달을 해준다. url에서 user:1q2w3e!을 파싱한 후에 인코딩을 통해 변환된 문자열을 가지고 있을테고, 이걸 요청 헤더 Authorization에 담아서 보내주는 개념이다.

그럼 이걸 서버가 받아서 db를 체크하고,<br>
db에 실제로 값이 있으면 ok라고 응답을 보내준다.

여기까지가 기본적으로 로그인을 하게 된 상황이다.

이때의 문제점은, 사용자가 계속해서 로그인을 해줘야 한다는 점이다. 매번 인증을 해야 한다.

## Browser Storage (localStorage, sessionStorage, cookie)

### 2. Browser 활용하기

이걸 해결하기 위해 브라우저에 있는 스토리지(로컬스토리지, 세션스토리지, 쿠키)의 힘을 빌린다.

쿠키로 설명을 하자면, 간단하게 쿠키에 사용자의 id와 pw를 넣는다. 그럼 사용자가 인증이 필요한 요청을 할 때 요청 헤더 Authorization과 같이 보내주는 개념이다.

그럼 채팅을 치거나, 글을 쓰거나 하는 등 사용자는 원하는 자원을 계속 받을 수 있게 된다.

근데 이렇게 브라우저의 힘을 빌리는 방식은<br>
사용자도 편리하지만, 해커도 편리하다.<br>
왜냐면 브라우저의 스토리지에 raw하게 사용자 정보가 담겨 있으니까 가져갈 수 있기 때문이다. 그리고 클라이언트라는 게 서버보다 상대적으로 보안에 취약하다는 단점이 있다.

## Session

### 3. Session 활용하기

이런 2가지 단점을 보완하기 위해서, 보안을 높이기 위해서,<br>
이번에는 서버에 도움을 요청한다.

처음엔 똑같다. 아까처럼 로그인 요청을 보낸다.<br>
보낸 로그인 요청을 바탕으로 db까지 거쳐서 인증이 완료된 상태에서 아까라면, 원하는 자원을 바로 클라이언트로 접근 가능하게 해줬을 것이다.

근데 그렇게 하지 않고 세션이라는 개념을 도입한다.<br>
세션은 인증된 사용자의 식별자와 랜덤한 문자열로 세션ID를 만들어서 이걸 응답 헤더에 set-cookie로 클라이언트로 넘겨주고, 클라이언트가 이걸 저장할 수 있게 만드는 것이다.

이렇게 했을 때의 장점은<br>
클라이언트 쪽에서 사용자의 raw한 데이터를 가지고 있지 않으니까, 해커가 이걸 가지고 가더라도 크게 위험하지 않다는 것이다.<br>
그리고 세션의 만료 기간을 정할 수 있기 때문에, 만료 기간이 지나게 될 경우 아무리 해커가 가져가더라도 유효하지 않다는 게 또 다른 장점이 된다.

그리고 이 세션 관리를 서버 자체에서 하고 있기 때문에<br>
탈취된 세션을 서버에서 삭제해버리면 세션 자체를 이용하지 못하게 된다.

물론 세션을 활용하는 것에도 문제점이 존재한다.

해당 웹서비스의 사용자가 많아져서 서버를 여러 개 두었다고 가정하면. 그럼 로드 밸런서도 생긴다. 이 상황에서 시작한다.

똑같이 로그인 요청 보내서 db에서 확인하고 세션 찾아서 클라이언트로 쏴준다. 한번 인증을 해서 세션을 받았을 때, 그 다음 요청을 세션을 사용해서만 요청을 하게 된다. 이 말은 db까지 거쳐갈 필요가 없다는 의미이다.

이 상황에서 사용자가 2번째 인증이 필요한 요청을 하게 되었을 때. 이때 로드 밸런서가 이전에 요청했던 서버가 아니라 다른 서버로 요청을 보내버린다. 이전에 요청했던 서버에만 세션ID가 존재하는데, 다른 서버에는 세션ID가 없으니 에러가 발생한다.

서버 하나하나 자체에서 세션을 관리하고 있기 때문에 발생하는 문제이다.

이 문제를 어떻게 해결했냐면, 세션 스토리지라는 걸 둬서 해결했다. 서버들에서 관리하는 모든 세션들을 세션 스토리지 한 곳에서 관리하자. 그럼 로드밸런서가 다른 서버로 쏘더라도 결국 세션 스토리지라는 이 한 곳으로 쏴지기 때문에 문제를 해결할 수 있다.

얘도 문제가 있다. 어떤 문제냐면 클라이언트가 많아질 경우 문제가 발생한다. 계속 쏜다. 여러 클라이언트가 계속 쏘니까 세션 스토리지가 버티질 못한다.

브라우저, 서버, 세션스토리지<br>
이 3개 모두 사용자의 상태정보를 한번씩 관리할 수 있게 만든 구조였다. 그랬더니 문제가 생긴 거다.

이들 간 통신할 때 사용하는 HTTP와 서버 자체가 지향하는 REST API가 무상태성을 기초로 하기 때문이다. 실제로 인증과 인가를 구현할 때는 사용자의 상태 정보를 이 3개가 모두 가지고 있게 된다. 즉, 상태성을 가지고 있다는 의미이다. 두 패러다임이 충돌하고 있는 상황이 된 것이다.

지금까지 브라우저에도 사용자의 상태를 맡겨봤고<br>
서버에도 사용자의 상태를 맡겨봤으니,<br>
이제 남은 건 이들 사이의 통신을 담당하는 HTTP에 맡겨 보자. 라는 것.

## Token

정보의 요청과 응답 contents 안에 우리 사용자의 상태를 담아 보자. 그걸로만 사용자의 인증과 인가를 처리하자는 개념이 TOKEN을 활용한 인증과 인가 방법이다.

그중에서 우리는 JSON WEB TOKEN (JWT)을 사용한다.<br>
간단하게 설명하자면, 시크릿키를 사용해서 JWT를 만들어 낸다. 그리고 이 시크릿키를 사용해서 JWT에 인증 과정을 거치게 된다.

JWT 자체는 해독하기가 무척 쉽다.<br>
그래서 JWT 내에는 민감한 정보를 담지 않는다.

이 시크릿키가 중요한 만큼, 노출되면 JWT 자체도 의미가 없어진다. 그래서 이 시크릿키를 서버 내부에 잘 관리해야 한다.

### 4. JWT 활용하기

맨 처음은 똑같다. 로그인을 한다. 클라이언트에서 로그인 요청을 보낸다. db가 확인하고 응답을 보내준다. 원래 같으면 세션 스토리지와 연결되었을텐데, 그렇지 않고 시크릿키를 이용해서 토큰을 만들어낸다.

요청 헤더 set-cookie: access=에 넣어서<br>
다음부터는 이 키를 사용해서 요청과 응답을 주고 받게 된다.

토큰이 클라이언트로부터 서버로 넘어가면(요청을 하면)<br>
서버는 이 토큰의 유효성 검사를 본인이 가진 시크릿키로 진행을 한다.

이때 유효하지 않으면 버리는 거고, 유효하다면 다음 단계인 사용자 정보를 파악한다. 디코딩하기 쉽기 때문에.

사용자 이름으로 어떤 유저인지 찾아내고<br>
만료시기를 가지고 만료된 토큰인지 아닌지 판단하고<br>
이 사용자의 권한도 토큰에서 확인할 수 있다.

하지만 비밀번호는 여기에 담으면 안 된다.<br>
비밀번호를 담게 되면, 디코딩하기 쉬워서 노출 우려가 있어서. 그리고 시크릿키를 통해서 유효성 검사를 통과했다는 인증을 받은 토큰이다.

JWT 활용하는 것의 장점은?<br>
세션은 세션DB를 따로 둬서 각 서버들이 세션DB와 연관성이 있었다. 이제는 로드밸런서가 쏘는 걸 서버 각자 가진 시크릿키로 해독을 해서 인증을 진행하면 된다는 장점이 있다.

이 장점이 좀 더 나아가서는 현대 서버 시스템의 확장성과도 연관이 된다. 서버의 개수가 늘어나도 똑같이 진행할 수 있다.

단점은 해킹을 또 당할 수 있다.<br>
엑세스 토큰을 탈취당하면, 해커가 사용자와 똑같은 지위를 갖게 된다. 사용자 자원에 접근할 수 있게 되므로.

이를 막기 위해서 만료기한을 정한다.<br>
만료 기한이 30분이면, 30분이 지나면 해커도 사용할 수 없고 사용자도 사용할 수 없게 된다.

사용자 입장에선 불편하기 때문에 나온 개념이 바로<br>
Refresh Token이라는 개념이다.

맨 처음엔 똑같이 로그인 요청을 클라이언트에서 서버로 보낸다. 보낸 로그인 요청에 따라서 시크릿키를 통해서 토큰을 만들어내는데, 이때 서버는 엑세스 토큰과 Refresh Token을 한번에 만들어 낸다.

그리고 서버에서는 엑세스 토큰은 저장하지 않고 리프레시 토큰만 따로 DB에 저장한다. 그리고 이 2개를 한번에 응답 헤더로 보내서 클라이언트가 둘 다 저장하게 된다.

엑세스 토큰이 만료됐을 경우<br>
사용자는 엑세스 토큰이 만료되었다는 사실을 모르고 알 필요도 없다. 이 상태로 요청을 보내게 된다. 이때 서버는 만료됐어 라고 응답한다. 그럼 이제 브라우저에서 자동으로<br>
엑세스 토큰과 리프레시 토큰을 함께 서버로 다시 보내고<br>
서버는 돌아온 리프레시 토큰을 참고해서 DB를 찔러서 동일하면 새로 갱신한 엑세스 토큰을 응답으로 보내준다.<br>
그럼 클라이언트에서도 업데이트된 엑세스 토큰을 사용할 수 있게 된다.

토큰 활용의 핵심

토큰으로 상태 관리를 하기 때문에 별도로 세션을 둘 필요가 없다. 토큰도 관리해야 한다. 토큰도 탈취당할 수 있기 때문이다.

### 추가 공부해볼 만한 것들

인증 서버를 따로 두는 방법이나,<br>
HTTPONLY 방법이나,<br>
Sliding session 등의 방법도 존재한다.<br>
SSL, TLS 1.3 을 사용하는 게 가장 쉬운 보안 방법(https를 사용하는 방법)

## OAuth

회원가입은 내 정보를 등록하는 과정이고<br>
로그인은 내가 누구인지 입증하는 과정이다.

인증(Authentication)은 보호된 리소스에 접근하는 것을 허용하기 이전에 등록된 유저의 신원을 입증하는(validating) 과정이다.<br>
인가(Authorization)은 요청된 리소스에 접근할 수 있는 권한이 있는 인증된(authenticated) 유저인지 입증하는(validating) 과정이다.<br>
즉, 인증이 인가보다 선행된다.

OAuth는 다른 웹사이트 상의 자신의 정보에 대해 접근 권한을 부여할 수 있는 공통적인 수단이자 개방형 표준이다.

### 깃허브 프로세스 예시

> 유저 브라우저 -- 서비스 -- OAuth 제공자(예를 들어 깃허브)

### OAuth 인증 과정

사용자가 브라우저에서 로그인 버튼을 누르면<br>
OAuth 제공자인 깃허브의 로그인 페이지를 요청하게 된다.

사용자가 나 깃허브 계정 있어!라고 응답하면<br>
깃허브에서 브라우저에게 어떤 코드를 반환해준다.

이 코드를 가지고 엑세스 토큰을 받을 수 있다.<br>
클라이언트에서 메인페이지의 쿼리 파라미터로 이 전달 받은 코드가 붙어 있으면, 자동으로 렌더링되기 이전 시점에 브라우저가 요청을 보낸다.

그럼 서비스가 엑세스 토큰을 달라고 코드와 함께 OAuth 제공자인 깃허브에게 요청을 한다. 그럼 깃허브에서 엑세스 토큰을 서비스에게 전달해준다.

### OAuth로 API 이용 과정

이제 유저 브라우저에서 어떤 요청을 보낼 때,<br>
서비스의 서버에 저장된 엑세스 토큰으로 서비스가 OAuth 제공자에게 해달라고 요청하면, 그에 맞는 걸 깃허브가 대신 해주고, 그걸 서비스가 대신 전달해주는 셈이다.

깃허브 OAuth는 OAuth 2.0이며, Authorization Code Grant 방식을 사용한다.<br>
클라이언트가 다른 사용자 대신 특정 리소스에 접근을 요청할 때 사용한다.

### OAuth 1.0 => 2.0 변화

1. 인증 절차 간소화

기능 단순화 및 규모 확장성 지원을 위해<br>
디지털 서명 기반의 암호화 => HTTPS의 암호화에 맡긴다.

2. 용어 변경

3. 다양한 인증 방식 제공

깃허브가 Authorization Code Grant 방식이었지만,
그외 다양한 방식이 존재한다.

- Implicit Grant
- Resource Owner Password Credentials Grant
- Client Credentials Grant
- Device Code Grant
- Refresh Token Grant

### OAuth의 장점

- 사용자는 서비스에 ID/PW를 알려주지 않아도 된다.
- 원할 때 엑세스 토큰의 권한 취소가 가능하다.
- 서비스는 유저의 엑세스 토큰만 가지고 있으면 된다.
- 사용자의 IP/PW를 몰라도 허가 받은 API 접근이 가능하다.

### 프론트엔드 처리 시

- route 이동 시 (이동을 못하게 하거나)
- 렌더링 시 (아예 다른 화면을 보여주거나)

## 참고자료

- [[10분 테코톡] 🎡토니의 인증과 인가](https://www.youtube.com/watch?v=y0xMXlOAfss)
- [[10분 테코톡] 🤠루피의 인증과 인가](https://www.youtube.com/watch?v=JZgD8aPkHSc&t=62s)
